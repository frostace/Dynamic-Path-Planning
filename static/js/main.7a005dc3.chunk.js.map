{"version":3,"sources":["Square.jsx","Board.jsx","algorithms/minHeap.js","Game.jsx","algorithms/astar.js","serviceWorker.js","index.js"],"names":["Square","props","col","row","isFinish","isStart","isWall","extraClassName","id","className","onMouseOver","onClick","Board","board_rows","this","allRows","map","oneRowOfSquares","i","key","onMouseDown","onMouseUp","React","Component","MinHeap","heap","temp","remove","node","push","curr","length","Math","floor","f","idx","splice","heapify","min_idx","l","r","neighborCandidates","Game","squareIndices","Array","x","fill","j","state","mouseIsDown","squareList","boardSquareNodes","boardSquareIsWall","stepNumber","xIsNext","handleMouseFlip","bind","handleMouseUpAndDown","startSearch","nodes","getInitialBoard","setState","tmpSquares","slice","e","prevState","runPathFinding","visitedNodesInOrder","nodesInShortestPathOrder","setTimeout","animateShortestPath","document","getElementById","startNode","finishNode","board","H","insert","visited","indexOf","currNode","popMin","undefined","neighbors","delta","nextNode","tempg","g","tempf","h","previousNode","console","log","astar","currentNode","unshift","getNodesInShortestPathOrder","animatePathFinding","rows","oneRowOfIndices","rowIdx","colIdx","nodeIdx","handleMouseClick","grid","currentRow","createNode","isVisited","Infinity","getHeuristic","getNeighborCoords","sqrt","output","forEach","element","dx","dy","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.7a005dc3.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./assets/square.css\";\n\nfunction Square(props) {\n\t// console.log(props);\n\tconst { col, row, isFinish, isStart, isWall } = props;\n\tconst extraClassName = isFinish\n\t\t? \"square-finish\"\n\t\t: isStart\n\t\t? \"square-start\"\n\t\t: isWall\n\t\t? \"square-wall\"\n\t\t: \"\";\n\n\treturn (\n\t\t<button\n\t\t\tid={props.id}\n\t\t\t// className={`square ${extraClassName}`}\n\t\t\t// onMouseDown={() => onMouseDown(row, col)}\n\t\t\t// onMouseEnter={() => onMouseEnter(row, col)}\n\t\t\t// onMouseUp={() => onMouseUp()}\n\t\t\t// style={{ background: props.color }}\n\t\t\tclassName={`square ${extraClassName}`}\n\t\t\tonMouseOver={props.onMouseOver}\n\t\t\tonClick={props.onClick}\n\t\t></button>\n\t);\n}\n\nexport default Square;\n","import React from \"react\";\nimport Square from \"./Square.jsx\";\n\nclass Board extends React.Component {\n\trender() {\n\t\tvar board_rows = this.props.allRows.map((oneRowOfSquares, i) => {\n\t\t\treturn (\n\t\t\t\t<div key={i} className=\"board-row\">\n\t\t\t\t\t{oneRowOfSquares}\n\t\t\t\t</div>\n\t\t\t);\n\t\t});\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tonMouseDown={this.props.onMouseDown}\n\t\t\t\tonMouseUp={this.props.onMouseUp}\n\t\t\t>\n\t\t\t\t{board_rows}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default Board;\n","// ==================================================\n// define heap structure\nexport class MinHeap {\n\tconstructor() {\n\t\t/* Initialing the array heap and adding a dummy element at index 0 */\n\t\tthis.heap = [];\n\t}\n\n\tpopMin() {\n\t\tvar temp = this.heap[0];\n\t\tthis.remove(0);\n\t\treturn temp;\n\t}\n\n\tinsert(node) {\n\t\tthis.heap.push(node);\n\t\tvar curr = this.heap.length - 1;\n\t\t// console.log(curr, this.heap);\n\t\twhile (\n\t\t\tcurr !== 0 &&\n\t\t\tthis.heap[Math.floor(curr / 2)].f > this.heap[curr].f\n\t\t) {\n\t\t\t[this.heap[Math.floor(curr / 2)], this.heap[curr]] = [\n\t\t\t\tthis.heap[curr],\n\t\t\t\tthis.heap[Math.floor(curr / 2)]\n\t\t\t];\n\t\t\tcurr = Math.floor(curr / 2);\n\t\t}\n\t}\n\n\tremove(idx) {\n\t\t// swap idx with the last node, heapify the whole tree\n\t\t[this.heap[idx], this.heap[this.heap.length - 1]] = [\n\t\t\tthis.heap[this.heap.length - 1],\n\t\t\tthis.heap[idx]\n\t\t];\n\t\t// remove the last node\n\t\tthis.heap.splice(this.heap.length - 1, 1);\n\t\tthis.heapify(idx);\n\t}\n\n\theapify(idx) {\n\t\tvar min_idx = idx;\n\t\tlet l = idx * 2;\n\t\tlet r = idx * 2 + 1;\n\t\tif (l < this.heap.length && this.heap[l].f < this.heap[min_idx].f) {\n\t\t\tmin_idx = l;\n\t\t}\n\t\tif (r < this.heap.length && this.heap[r].f < this.heap[min_idx].f) {\n\t\t\tmin_idx = r;\n\t\t}\n\t\tif (min_idx !== idx) {\n\t\t\t[this.heap[min_idx], this.heap[idx]] = [\n\t\t\t\tthis.heap[idx],\n\t\t\t\tthis.heap[min_idx]\n\t\t\t];\n\t\t\tthis.heapify(min_idx);\n\t\t}\n\t}\n}\n// ==================================================\n","import React from \"react\";\nimport Board from \"./Board.jsx\";\nimport Square from \"./Square.jsx\";\nimport \"./assets/board.css\";\nimport update from \"react-addons-update\";\nimport { dijkstra } from \"./algorithms/dijkstra\";\nimport { astar } from \"./algorithms/astar\";\n\nconst originColor = \"white\";\nconst flippedColor = \"#0C3547\";\nconst boardRowNum = 49;\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\nconst neighborCandidates = [\n\t[1, 0],\n\t[-1, 0],\n\t[0, 1],\n\t[0, -1]\n];\n\nclass Game extends React.Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tvar squareIndices = [...Array(boardRowNum)].map(x =>\n\t\t\tArray(boardRowNum).fill(0)\n\t\t);\n\t\tfor (var i = 0; i < boardRowNum; i++) {\n\t\t\tfor (var j = 0; j < boardRowNum; j++) {\n\t\t\t\tsquareIndices[i][j] = i * boardRowNum + j;\n\t\t\t}\n\t\t}\n\t\tthis.state = {\n\t\t\tmouseIsDown: false,\n\t\t\tsquareList: squareIndices,\n\t\t\tboardSquareNodes: [],\n\t\t\tboardSquareIsWall: [...Array(boardRowNum)].map(x =>\n\t\t\t\tArray(boardRowNum).fill(false)\n\t\t\t),\n\t\t\tstepNumber: 0,\n\t\t\txIsNext: true\n\t\t};\n\t\tthis.handleMouseFlip = this.handleMouseFlip.bind(this);\n\t\tthis.handleMouseUpAndDown = this.handleMouseUpAndDown.bind(this);\n\t\tthis.startSearch = this.startSearch.bind(this);\n\t}\n\n\tcomponentDidMount() {\n\t\tconst nodes = getInitialBoard();\n\t\tthis.setState({ boardSquareNodes: nodes });\n\t}\n\n\thandleMouseFlip(i, j) {\n\t\tif (!this.state.mouseIsDown) return;\n\t\tconst tmpSquares = this.state.boardSquareNodes.slice();\n\t\ttmpSquares[i][j].isWall = !tmpSquares[i][j].isWall;\n\n\t\tthis.setState({\n\t\t\tboardSquareNodes: tmpSquares,\n\t\t\t// boardSquareIsWall: update(this.state.boardSquareIsWall, {\n\t\t\t// \ti: { $set: tmpSquares[i] }\n\t\t\t// }),\n\t\t\txIsNext: !this.state.xIsNext\n\t\t});\n\t}\n\n\thandleMouseClick(i, j) {\n\t\tconst tmpSquares = this.state.boardSquareNodes.slice();\n\t\ttmpSquares[i][j].isWall = !tmpSquares[i][j].isWall;\n\n\t\tthis.setState({\n\t\t\tboardSquareNodes: tmpSquares,\n\t\t\t// boardSquareIsWall: update(this.state.boardSquareIsWall, {\n\t\t\t// \ti: { $set: tmpSquares[i] }\n\t\t\t// }),\n\t\t\txIsNext: !this.state.xIsNext\n\t\t});\n\t}\n\n\thandleMouseUpAndDown(e) {\n\t\tthis.setState(prevState => {\n\t\t\treturn { mouseIsDown: !prevState.mouseIsDown };\n\t\t});\n\t}\n\n\tstartSearch() {\n\t\tthis.runPathFinding();\n\t}\n\n\tanimatePathFinding(visitedNodesInOrder, nodesInShortestPathOrder) {\n\t\tfor (let i = 0; i <= visitedNodesInOrder.length; i++) {\n\t\t\tif (i === visitedNodesInOrder.length) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.animateShortestPath(nodesInShortestPathOrder);\n\t\t\t\t}, 10 * i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst node = visitedNodesInOrder[i];\n\t\t\t\tdocument.getElementById(\n\t\t\t\t\t`square-${node.row}-${node.col}`\n\t\t\t\t).className = \"square square-visited\";\n\t\t\t}, 10 * i);\n\t\t}\n\t}\n\n\tanimateShortestPath(nodesInShortestPathOrder) {\n\t\tfor (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst node = nodesInShortestPathOrder[i];\n\t\t\t\tdocument.getElementById(\n\t\t\t\t\t`square-${node.row}-${node.col}`\n\t\t\t\t).className = \"square square-shortest-path\";\n\t\t\t}, 50 * i);\n\t\t}\n\t}\n\n\trunPathFinding() {\n\t\tconst { boardSquareNodes } = this.state;\n\t\tconst startNode = boardSquareNodes[START_NODE_ROW][START_NODE_COL];\n\t\tconst finishNode = boardSquareNodes[FINISH_NODE_ROW][FINISH_NODE_COL];\n\t\tconst visitedNodesInOrder = astar(\n\t\t\tboardSquareNodes,\n\t\t\tstartNode,\n\t\t\tfinishNode\n\t\t);\n\t\tconst nodesInShortestPathOrder = getNodesInShortestPathOrder(\n\t\t\tfinishNode\n\t\t);\n\t\tthis.animatePathFinding(visitedNodesInOrder, nodesInShortestPathOrder);\n\t}\n\n\trender() {\n\t\tvar rows = this.state.boardSquareNodes.map(\n\t\t\t(oneRowOfIndices, rowIdx) => {\n\t\t\t\treturn oneRowOfIndices.map((node, colIdx) => {\n\t\t\t\t\t// console.log(squIdx, overallIdx);\n\t\t\t\t\tconst {\n\t\t\t\t\t\trow,\n\t\t\t\t\t\tcol,\n\t\t\t\t\t\tnodeIdx,\n\t\t\t\t\t\tisFinish,\n\t\t\t\t\t\tisStart,\n\t\t\t\t\t\tisWall\n\t\t\t\t\t} = node;\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<Square\n\t\t\t\t\t\t\tid={`square-${rowIdx}-${colIdx}`}\n\t\t\t\t\t\t\tkey={nodeIdx}\n\t\t\t\t\t\t\tisStart={isStart}\n\t\t\t\t\t\t\tisFinish={isFinish}\n\t\t\t\t\t\t\tisWall={isWall}\n\t\t\t\t\t\t\t// color={this.state.boardSquareIsWall[overallIdx]}\n\t\t\t\t\t\t\tonMouseOver={() =>\n\t\t\t\t\t\t\t\tthis.handleMouseFlip(rowIdx, colIdx)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tonClick={() =>\n\t\t\t\t\t\t\t\tthis.handleMouseClick(rowIdx, colIdx)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t/>\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tclassName=\"game\"\n\t\t\t\t// onMouseUp={() => this.handleMouseUpAndDown}\n\t\t\t>\n\t\t\t\t<button onClick={this.startSearch}>start search</button>\n\t\t\t\t<div className=\"game-board\">\n\t\t\t\t\t<Board\n\t\t\t\t\t\tclassName=\"board\"\n\t\t\t\t\t\t// squares={this.state.boardSquareIsWall}\n\t\t\t\t\t\t// onClick={i => this.handleClick(i)}\n\t\t\t\t\t\tonMouseDown={this.handleMouseUpAndDown}\n\t\t\t\t\t\tonMouseUp={this.handleMouseUpAndDown}\n\t\t\t\t\t\tallRows={rows}\n\t\t\t\t\t/>{\" \"}\n\t\t\t\t</div>{\" \"}\n\t\t\t\t<div className=\"game-info\">\n\t\t\t\t\t{\" \"}\n\t\t\t\t\t{/* <div className=\"status\">{status}</div> */}{\" \"}\n\t\t\t\t\t{/* <ol class=\"moves\">{moves}</ol> */}{\" \"}\n\t\t\t\t</div>{\" \"}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nconst getInitialBoard = () => {\n\tconst grid = [];\n\tfor (let row = 0; row < boardRowNum; row++) {\n\t\tconst currentRow = [];\n\t\tfor (let col = 0; col < boardRowNum; col++) {\n\t\t\tcurrentRow.push(createNode(row, col));\n\t\t}\n\t\tgrid.push(currentRow);\n\t}\n\treturn grid;\n};\n\nconst createNode = (row, col) => {\n\treturn {\n\t\tcol,\n\t\trow,\n\t\tnodeIdx: row * boardRowNum + col,\n\t\tisStart: row === START_NODE_ROW && col === START_NODE_COL,\n\t\tisFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n\t\tisVisited: false,\n\t\tisWall: false,\n\t\t/*distance*/\n\t\tg: row === START_NODE_ROW && col === START_NODE_COL ? 0 : Infinity,\n\t\t/*heuristic*/\n\t\th: getHeuristic(row, col),\n\t\t/*modified distance*/\n\t\tf: row === START_NODE_ROW && col === START_NODE_COL ? 0 : Infinity,\n\t\tneighbors: getNeighborCoords(row, col),\n\t\tpreviousNode: null\n\t};\n};\n\nfunction getHeuristic(row, col) {\n\treturn Math.sqrt(\n\t\t(row - FINISH_NODE_ROW) * (row - FINISH_NODE_ROW) +\n\t\t\t(col - FINISH_NODE_COL) * (col - FINISH_NODE_COL)\n\t);\n}\n\nfunction getNeighborCoords(row, col) {\n\tvar output = [];\n\tneighborCandidates.forEach(element => {\n\t\tvar dx = element[0];\n\t\tvar dy = element[1];\n\t\tif (\n\t\t\trow + dx >= 0 &&\n\t\t\trow + dx < boardRowNum &&\n\t\t\tcol + dy >= 0 &&\n\t\t\tcol + dy < boardRowNum\n\t\t) {\n\t\t\toutput.push([row + dx, col + dy]);\n\t\t}\n\t});\n\treturn output;\n}\n\nfunction getNodesInShortestPathOrder(finishNode) {\n\tconst nodesInShortestPathOrder = [];\n\tlet currentNode = finishNode;\n\twhile (currentNode !== null) {\n\t\tnodesInShortestPathOrder.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\treturn nodesInShortestPathOrder;\n}\n\nfunction calculateWinner(squares) {\n\tconst lines = [\n\t\t[0, 1, 2],\n\t\t[3, 4, 5],\n\t\t[6, 7, 8],\n\t\t[0, 3, 6],\n\t\t[1, 4, 7],\n\t\t[2, 5, 8],\n\t\t[0, 4, 8],\n\t\t[2, 4, 6]\n\t];\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tconst [a, b, c] = lines[i];\n\t\tif (\n\t\t\tsquares[a] &&\n\t\t\tsquares[a] === squares[b] &&\n\t\t\tsquares[b] === squares[c]\n\t\t) {\n\t\t\treturn squares[a];\n\t\t}\n\t}\n\tfor (let i = 0; i < 9; i++) {\n\t\tif (squares[i] === null) {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn \"Tie\";\n}\n\nexport default Game;\n","import { MinHeap } from \"./minHeap\";\n\n// Astar\nexport function astar(board, startNode, finishNode) {\n\tlet H = new MinHeap();\n\tH.insert(startNode);\n\tlet visited = [];\n\n\twhile (visited.indexOf(finishNode) == -1 && H.length !== 0) {\n\t\tvar currNode = H.popMin();\n\t\tif (currNode === undefined) return [];\n\t\tvar neighbors = currNode.neighbors.map(delta => {\n\t\t\t// console.log(delta, board);\n\t\t\treturn board[delta[0]][delta[1]];\n\t\t});\n\n\t\t// === - add unvisited neighbors of curr to tovisit[] - ===\n\t\tfor (var i = 0; i < neighbors.length; i++) {\n\t\t\tlet nextNode = neighbors[i];\n\t\t\tif (visited.indexOf(nextNode) !== -1 || nextNode.isWall) continue; // don't visit twice\n\t\t\tlet tempg = currNode.g + 1;\n\t\t\tlet tempf = tempg + nextNode.h;\n\t\t\tif (tempg < nextNode.g) {\n\t\t\t\tnextNode.g = tempg;\n\t\t\t\tnextNode.f = tempf;\n\t\t\t\tnextNode.previousNode = currNode;\n\t\t\t\tH.insert(nextNode);\n\t\t\t}\n\t\t}\n\t\t// === - mark curr as visited - ===\n\t\tvisited.push(currNode);\n\t}\n\tif (visited.indexOf(finishNode) !== -1) {\n\t\t// noLoop();\n\t\t// drawBestPath(finishNode);\n\t\tconsole.log(\"done!\");\n\t\t// GOAL!!\n\t}\n\tif (H.heap.length === 0) {\n\t\tconsole.log(\"no solution\");\n\t}\n\treturn visited;\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./assets/index.css\";\nimport Game from \"./Game.jsx\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<Game />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n\nserviceWorker.unregister();\n"],"sourceRoot":""}